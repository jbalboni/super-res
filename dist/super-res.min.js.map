{"version":3,"sources":["/source/super-res.js","/source/src/create-requestor.js","super-res.min.js","/source/src/super-res.js","/source/src/superagent-adapter.js","/source/src/action-defaults.js"],"names":["global","factory","exports","module","require","define","amd","superRes","Q","superagent","Route","cacheManager","this","createResponseTransformer","transforms","response","resolve","reduce","memo","transform","header","body","applyRequestTransforms","data","canHaveData","method","methodUpper","toUpperCase","getParameters","defaultParamConfig","Object","getOwnPropertyNames","params","paramName","param","derivedParams","startsWith","slice","defaultParams","createCacheKeyGetter","route","reverse","JSON","stringify","checkCache","cache","key","deferred","defer","get","err","result","reject","found","promise","expandParams","computedParams","prop","create_requestor_js__assign","createRequestTransformer","createRequestor","url","action","config","actionDefaults","_getParameters","transformResponse","getCacheKey","caching","cacheDefault","arguments","length","undefined","fullParams","configuredHttpRequest","superagentAdapter","configureRequest","transformRequest","cacheKey","then","_ref","makeRequest","set","generateDefaultActions","resource","query","save","put","remove","superagentAdapter__exports","dataTransformer","toLowerCase","currentRequest","plugins","forEach","plugin","use","accept","responseType","headers","timeout","clearTimeout","withCredentials","transformedData","send","request","end","res","store","max","ttl","super_res__assign","actions","name","promiseWrapper","wrapperFunc","proxiedResource","actionFunction","_len","args","Array","_key","apply","super_res"],"mappings":"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","file":"super-res.min.js","sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('q'), require('superagent'), require('route-parser'), require('cache-manager')) :\n  typeof define === 'function' && define.amd ? define(['q', 'superagent', 'route-parser', 'cache-manager'], factory) :\n  global.superRes = factory(global.Q, global.superagent, global.Route, global.cacheManager)\n}(this, function (Q, superagent, Route, cacheManager) { 'use strict';\n\n  var superagentAdapter__exports = {};\n\n  superagentAdapter__exports.configureRequest = function configureRequest(config, url, dataTransformer) {\n    const method = config.method.toLowerCase();\n    let currentRequest = superagent[method === 'delete' ? 'del' : method](url);\n\n    // Setup superagent plugins\n    if (config.plugins && config.plugins.length) {\n      config.plugins.forEach((plugin) => {\n        currentRequest = currentRequest.use(plugin);\n      });\n    }\n\n    currentRequest = currentRequest.accept(config.responseType);\n    if (config.headers) {\n      currentRequest = currentRequest.set(config.headers);\n    }\n\n    if (config.timeout) {\n      currentRequest.timeout(config.timeout);\n    } else {\n      currentRequest.clearTimeout();\n    }\n\n    if (config.withCredentials) {\n      currentRequest = currentRequest.withCredentials();\n    }\n\n    const transformedData = dataTransformer(currentRequest.header);\n    if (transformedData) {\n      if (method === 'get') {\n        currentRequest = currentRequest.query(transformedData);\n      } else {\n        currentRequest = currentRequest.send(transformedData);\n      }\n    }\n\n    return currentRequest;\n  };\n\n  superagentAdapter__exports.makeRequest = function makeRequest(request) {\n    const deferred = Q.defer();\n    request.end((err, res) => {\n      if (err) {\n        deferred.reject(err);\n      } else {\n        deferred.resolve(res);\n      }\n    });\n    return deferred.promise;\n  };\n\n  var superagentAdapter = superagentAdapter__exports;\n\n  var actionDefaults = actionDefaults = {\n    method: 'GET',\n    responseType: 'json',\n    transformRequest: [],\n    transformResponse: [],\n    withCredentials: false,\n    cache: null,\n    plugins: []\n  };\n\n  const cacheDefault = {store: 'memory', max: 100, ttl: 1200};\n  const create_requestor_js__assign = create_requestor_js__assign || require('object.assign');\n\n\n  function createResponseTransformer(transforms) {\n    return function applyResponseTransforms(response) {\n      return Q.resolve(transforms.reduce(function(memo, transform) {\n        return transform(memo, response.header);\n      }, response.body));\n    };\n  }\n\n  function applyRequestTransforms(transforms, header, data) {\n    return transforms.reduce(function(memo, transform) {\n      return transform(memo, header);\n    }, data);\n  }\n\n  //Only certain http methods can have data sent with them\n  //This could be limiting to users\n  function canHaveData(method) {\n    const methodUpper = method.toUpperCase();\n    return methodUpper === 'POST' || methodUpper === 'PUT' || methodUpper === 'PATCH';\n  }\n\n  function getParameters(defaultParamConfig) {\n    return Object.getOwnPropertyNames(defaultParamConfig)\n      .reduce((params, paramName) => {\n        let param = defaultParamConfig[paramName];\n        if (typeof param === 'function') {\n          params.derivedParams[paramName] = param;\n        } else if (typeof param === 'string' && param.startsWith('@')) {\n          params.derivedParams[paramName] = param.slice(1);\n        } else {\n          //add to default if it's not an @ or function param\n          params.defaultParams[paramName] = param;\n        }\n        return params;\n      }, {derivedParams: {}, defaultParams: {}});\n  }\n\n  function createCacheKeyGetter(route) {\n    return function getCacheKey(params, data) {\n      return route.reverse(params) + JSON.stringify(data || {});\n    }\n  }\n\n  function checkCache(method, cache, key) {\n    const deferred = Q.defer();\n    if (cache && method.toUpperCase() === 'GET') {\n      cache.get(key, (err, result) => {\n        if (err) {\n          deferred.reject(err);\n        } else if (result) {\n          deferred.resolve({found: true, result});\n        } else {\n          deferred.resolve({found: false});\n        }\n      })\n    } else {\n      deferred.resolve({found: false});\n    }\n    return deferred.promise;\n  }\n\n  function expandParams(derivedParams, defaultParams, data) {\n    return Object.getOwnPropertyNames(derivedParams)\n      .reduce((computedParams, prop) => {\n        let param = derivedParams[prop];\n        if (typeof param === 'function') {\n          computedParams[prop] = param();\n        } else {\n          computedParams[prop] = data[param];\n        }\n        return computedParams;\n      }, create_requestor_js__assign({}, defaultParams));\n  }\n\n  function createRequestTransformer(transform, data) {\n    return (header) => {\n      return data ? applyRequestTransforms(transform, header, data) : null;\n    }\n  }\n\n  /*\n   * Returns a function that will make http requests based on the configuration passed to it\n   */\n  function createRequestor(url, defaultParamConfig, action) {\n    const config = create_requestor_js__assign({url: url}, actionDefaults, action);\n    const route = new Route(config.url);\n    const {derivedParams, defaultParams} = getParameters(defaultParamConfig || {});\n    const transformResponse = createResponseTransformer(config.transformResponse);\n    const getCacheKey = createCacheKeyGetter(route);\n\n    config.cache = config.cache === true ? cacheManager.caching(cacheDefault) : config.cache;\n\n    return function(params, data) {\n      //if there's only one argument, assume it's the data instead of the second param\n      //I don't like this, but it is consistent with angular-resource\n      if (arguments.length === 1 && canHaveData(config.method)) {\n        data = params;\n        params = undefined;\n      }\n      const fullParams = create_requestor_js__assign(expandParams(derivedParams, defaultParams, data), params);\n      const url = route.reverse(fullParams);\n      //The superagent interface has two phases, configure and makeRequest. The need for this is debatable\n      const configuredHttpRequest = superagentAdapter.configureRequest(config, url, createRequestTransformer(config.transformRequest, data));\n      const cacheKey = getCacheKey(fullParams, data);\n      return checkCache(config.method, config.cache, cacheKey)\n        .then(function cacheSuccess({found, result}) {\n          if (found) {\n            return Q.resolve(result);\n          } else {\n            return superagentAdapter.makeRequest(configuredHttpRequest)\n              .then(transformResponse)\n              .then(function cacheResponse(response) {\n                if (config.cache) {\n                  config.cache.set(cacheKey, response);\n                }\n                return Q.resolve(response);\n              });\n          }\n\n        });\n    }\n  }\n\n  var super_res__assign = super_res__assign || require('object.assign');\n\n  const superRes = {};\n\n  function generateDefaultActions(url, defaultParams) {\n    const resource = {};\n\n    resource.get = createRequestor(url, defaultParams);\n    resource.query = resource.get;\n    resource.save = createRequestor(url, defaultParams, {method: 'POST'});\n    resource.put = createRequestor(url, defaultParams, {method: 'PUT'});\n    resource.remove = createRequestor(url, defaultParams, {method: 'DELETE'});\n    resource['delete'] = resource.remove;\n\n    return resource;\n  }\n\n  superRes.resource = (url, defaultParams, actions) => {\n    const resource = generateDefaultActions(url, defaultParams);\n    if (actions) {\n      Object.getOwnPropertyNames(actions).forEach((name) => {\n        resource[name] = createRequestor(url, defaultParams, actions[name]);\n      });\n    }\n    return resource;\n  };\n\n  superRes.promiseWrapper = function promiseWrapper(wrapperFunc) {\n    return (resource) => {\n      let proxiedResource = super_res__assign({}, resource);\n      Object.getOwnPropertyNames(resource).forEach((name) => {\n        let actionFunction = proxiedResource[name];\n        proxiedResource[name] = function(...args) {\n          let promise = actionFunction.apply(proxiedResource, args);\n          return wrapperFunc(promise);\n        }\n      });\n      return proxiedResource;\n    }\n  };\n\n  var super_res = superRes;\n\n  return super_res;\n\n}));\n","import Q from 'q';\nimport request from 'superagent';\nimport Route from 'route-parser';\nimport cacheManager from 'cache-manager';\n\nimport superagentAdapter from './superagent-adapter.js';\nimport actionDefaults from './action-defaults.js';\n\nconst cacheDefault = {store: 'memory', max: 100, ttl: 1200};\nconst assign = assign || require('object.assign');\n\n\nfunction createResponseTransformer(transforms) {\n  return function applyResponseTransforms(response) {\n    return Q.resolve(transforms.reduce(function(memo, transform) {\n      return transform(memo, response.header);\n    }, response.body));\n  };\n}\n\nfunction applyRequestTransforms(transforms, header, data) {\n  return transforms.reduce(function(memo, transform) {\n    return transform(memo, header);\n  }, data);\n}\n\n//Only certain http methods can have data sent with them\n//This could be limiting to users\nfunction canHaveData(method) {\n  const methodUpper = method.toUpperCase();\n  return methodUpper === 'POST' || methodUpper === 'PUT' || methodUpper === 'PATCH';\n}\n\nfunction getParameters(defaultParamConfig) {\n  return Object.getOwnPropertyNames(defaultParamConfig)\n    .reduce((params, paramName) => {\n      let param = defaultParamConfig[paramName];\n      if (typeof param === 'function') {\n        params.derivedParams[paramName] = param;\n      } else if (typeof param === 'string' && param.startsWith('@')) {\n        params.derivedParams[paramName] = param.slice(1);\n      } else {\n        //add to default if it's not an @ or function param\n        params.defaultParams[paramName] = param;\n      }\n      return params;\n    }, {derivedParams: {}, defaultParams: {}});\n}\n\nfunction createCacheKeyGetter(route) {\n  return function getCacheKey(params, data) {\n    return route.reverse(params) + JSON.stringify(data || {});\n  }\n}\n\nfunction checkCache(method, cache, key) {\n  const deferred = Q.defer();\n  if (cache && method.toUpperCase() === 'GET') {\n    cache.get(key, (err, result) => {\n      if (err) {\n        deferred.reject(err);\n      } else if (result) {\n        deferred.resolve({found: true, result});\n      } else {\n        deferred.resolve({found: false});\n      }\n    })\n  } else {\n    deferred.resolve({found: false});\n  }\n  return deferred.promise;\n}\n\nfunction expandParams(derivedParams, defaultParams, data) {\n  return Object.getOwnPropertyNames(derivedParams)\n    .reduce((computedParams, prop) => {\n      let param = derivedParams[prop];\n      if (typeof param === 'function') {\n        computedParams[prop] = param();\n      } else {\n        computedParams[prop] = data[param];\n      }\n      return computedParams;\n    }, assign({}, defaultParams));\n}\n\nfunction createRequestTransformer(transform, data) {\n  return (header) => {\n    return data ? applyRequestTransforms(transform, header, data) : null;\n  }\n}\n\n/*\n * Returns a function that will make http requests based on the configuration passed to it\n */\nexport default function createRequestor(url, defaultParamConfig, action) {\n  const config = assign({url: url}, actionDefaults, action);\n  const route = new Route(config.url);\n  const {derivedParams, defaultParams} = getParameters(defaultParamConfig || {});\n  const transformResponse = createResponseTransformer(config.transformResponse);\n  const getCacheKey = createCacheKeyGetter(route);\n\n  config.cache = config.cache === true ? cacheManager.caching(cacheDefault) : config.cache;\n\n  return function(params, data) {\n    //if there's only one argument, assume it's the data instead of the second param\n    //I don't like this, but it is consistent with angular-resource\n    if (arguments.length === 1 && canHaveData(config.method)) {\n      data = params;\n      params = undefined;\n    }\n    const fullParams = assign(expandParams(derivedParams, defaultParams, data), params);\n    const url = route.reverse(fullParams);\n    //The superagent interface has two phases, configure and makeRequest. The need for this is debatable\n    const configuredHttpRequest = superagentAdapter.configureRequest(config, url, createRequestTransformer(config.transformRequest, data));\n    const cacheKey = getCacheKey(fullParams, data);\n    return checkCache(config.method, config.cache, cacheKey)\n      .then(function cacheSuccess({found, result}) {\n        if (found) {\n          return Q.resolve(result);\n        } else {\n          return superagentAdapter.makeRequest(configuredHttpRequest)\n            .then(transformResponse)\n            .then(function cacheResponse(response) {\n              if (config.cache) {\n                config.cache.set(cacheKey, response);\n              }\n              return Q.resolve(response);\n            });\n        }\n\n      });\n  }\n}\n",null,"var assign = assign || require('object.assign');\n\nimport createRequestor from './create-requestor.js';\n\nconst superRes = {};\n\nfunction generateDefaultActions(url, defaultParams) {\n  const resource = {};\n\n  resource.get = createRequestor(url, defaultParams);\n  resource.query = resource.get;\n  resource.save = createRequestor(url, defaultParams, {method: 'POST'});\n  resource.put = createRequestor(url, defaultParams, {method: 'PUT'});\n  resource.remove = createRequestor(url, defaultParams, {method: 'DELETE'});\n  resource['delete'] = resource.remove;\n\n  return resource;\n}\n\nsuperRes.resource = (url, defaultParams, actions) => {\n  const resource = generateDefaultActions(url, defaultParams);\n  if (actions) {\n    Object.getOwnPropertyNames(actions).forEach((name) => {\n      resource[name] = createRequestor(url, defaultParams, actions[name]);\n    });\n  }\n  return resource;\n};\n\nsuperRes.promiseWrapper = function promiseWrapper(wrapperFunc) {\n  return (resource) => {\n    let proxiedResource = assign({}, resource);\n    Object.getOwnPropertyNames(resource).forEach((name) => {\n      let actionFunction = proxiedResource[name];\n      proxiedResource[name] = function(...args) {\n        let promise = actionFunction.apply(proxiedResource, args);\n        return wrapperFunc(promise);\n      }\n    });\n    return proxiedResource;\n  }\n};\n\nexport default superRes;\n","import request from 'superagent';\nimport Q from 'q';\n\nvar exports = {};\n\nexports.configureRequest = function configureRequest(config, url, dataTransformer) {\n  const method = config.method.toLowerCase();\n  let currentRequest = request[method === 'delete' ? 'del' : method](url);\n\n  // Setup superagent plugins\n  if (config.plugins && config.plugins.length) {\n    config.plugins.forEach((plugin) => {\n      currentRequest = currentRequest.use(plugin);\n    });\n  }\n\n  currentRequest = currentRequest.accept(config.responseType);\n  if (config.headers) {\n    currentRequest = currentRequest.set(config.headers);\n  }\n\n  if (config.timeout) {\n    currentRequest.timeout(config.timeout);\n  } else {\n    currentRequest.clearTimeout();\n  }\n\n  if (config.withCredentials) {\n    currentRequest = currentRequest.withCredentials();\n  }\n\n  const transformedData = dataTransformer(currentRequest.header);\n  if (transformedData) {\n    if (method === 'get') {\n      currentRequest = currentRequest.query(transformedData);\n    } else {\n      currentRequest = currentRequest.send(transformedData);\n    }\n  }\n\n  return currentRequest;\n};\n\nexports.makeRequest = function makeRequest(request) {\n  const deferred = Q.defer();\n  request.end((err, res) => {\n    if (err) {\n      deferred.reject(err);\n    } else {\n      deferred.resolve(res);\n    }\n  });\n  return deferred.promise;\n};\n\nexport default exports;","export default actionDefaults = {\n  method: 'GET',\n  responseType: 'json',\n  transformRequest: [],\n  transformResponse: [],\n  withCredentials: false,\n  cache: null,\n  plugins: []\n};"],"sourceRoot":"/source/"}